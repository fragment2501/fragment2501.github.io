---
title: SQL - Parent child relationship trees
date: '2006-01-09T13:52:00.000-08:00'
author: Bryan
tags:
- Oracle
modified_time: '2008-02-13T13:41:45.799-08:00'
blogger_id: tag:blogger.com,1999:blog-19111454.post-113684407208085622
blogger_orig_url: http://www.bryansgeekspeak.com/2006/01/sql-parent-child-relationship-trees.html
---

--- WORK IN PROGRESS ---<br /><br />I'm still tyring to finish this writeup on my understanding of oracle trees.  Please feel free to post comments/suggestions.<br /><br />I've been working on a project where the client can manage a list of categories  with an unlimited level of subcategories.  The result is a tree structure that looks something like this:<br /><br />category1<br />--subcategory1<br />--subcategory2<br />    ----subsubcategory1<br /><br />category2<br />--subcategory3<br /><br />Note that the first category1 has 3 tiers (category, subcategory and subsubcategory) while category2 has only 2 tiers.<br /><br />I need to be able to create a unlimited level tree structure from this data for web site navigation.  To get this to work I created a parent child relationship in a DB table as shown below.<br /><br />--- using oracle style sql<br /><br />CREATE TABLE categories (<br />category_id INT NOT NULL PRIMARY KEY,<br />category_name VARCHAR2(128) NOT NULL,<br />parent_id INT NULL<br />);<br /><br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(1,'category1',NULL);<br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(2,'subcategory1',1);<br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(3,'subcategory2',1);<br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(4,'subsubcategory1',3);<br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(5,'category2',NULL);<br />INSERT INTO categories (category_id, category_name,parent_id)<br />VALUES(6,'subcategory3',5);<br />COMMIT;<br /><br />You end up with rows of data in the table that look like the following matrix.<br /><br /><table border="1"><br /><tbody><tr><th>category_id</th><th>category_name</th><th>parent_id</th></tr><br /><tr><td>1</td><td>category1</td><td>NULL</td></tr><br /><tr><td>2</td><td>subcategory1</td><td>1</td></tr><br /><tr><td>3</td><td>subcategory2</td><td>1</td></tr><br /><tr><td>4</td><td>subsubcategory1</td><td>3</td></tr><br /><tr><td>5</td><td>category2</td><td>NULL</td></tr><br /><tr><td>6</td><td>subcategory3</td><td>5</td></tr><br /></tbody></table><br /><br />The category_id column is the unique primary key for records in this table.  The parent_id is a foreign key to the primary key column in the same table.  The parent_id links the current row to a parent record in the same table.  In short, the parent_id tells us if the current record has a parent (NULL means no parent) and who that parent is.  We will use this relationship to "Walk the tree" where given any category_id, we can find all of its parents and all of its children within the tree.<br /><br />When building a navigation menu, we tend to start at the top and work our way down.  To do that, we need to start with all the top level parent categories.  We know we are at the "top" of the list when we have a record with no parent (NULL for the parent_id).<br /><br /><pre><br />--- Select all top level categories<br />SELECT * FROM categories WHERE parent_id IS NULL;<br /><br />category_id  category_name  parent_id<br />-----------  -------------  ---------<br />1            category1      (null)<br />6            category2      (null)<br /><br />2 record(s) selected<br /></pre><br /><br />If you look at the original tree drawing, this query does return the top level parent records.  Now its time to put this simple parent/child relationship to the test and if it can be usefull as it is or if we need to add more data to make it work.  <br /><br /><br />Lets try to create the navigation.<br /><br /><pre><br />SELECT * FROM categories;<br /><br />CATEGORY_ID     CATEGORY_NAME     PARENT_ID    <br /> --------------  ----------------  ------------ <br /> 1               category1         (null)       <br /> 2               subcategory1      1            <br /> 3               subcategory2      1            <br /> 4               subsubcategory1   3            <br /> 5               category2         (null)       <br /> 6               subcategory3      5            <br /><br /> 6 record(s) selected<br /></pre><br /><br />Everything looks ok, but there is a hidden problem.  How do we know these records are in the correct order?  In this case, pure dum luck.  If we change our example data we can see the problem more clearly:<br /><br /><pre><br />DROP TABLE categories;<br /><br />CREATE TABLE categories ( <br /> CATEGORY_ID   NUMBER(22,0) NOT NULL,<br /> CATEGORY_NAME VARCHAR2(128) NOT NULL,<br /> PARENT_ID     NUMBER(22,0) NULL,<br /> SORT_ORDER    NUMBER(22,0) NOT NULL <br /> );<br /><br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(1, 'category3', NULL);<br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(2, 'subcategory5', 1);<br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(3, 'subcategory4', 1);<br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(4, 'subsubcategory4', 3);<br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(5, 'category2', NULL);<br />INSERT INTO categories(category_id, category_name, parent_id)<br />  VALUES(6, 'subcategory3', 5);<br /><br />COMMIT;<br /><br /><br />SELECT * FROM categories;<br /><br /> CATEGORY_ID     CATEGORY_NAME     PARENT_ID    <br /> --------------  ----------------  ------------ <br /> 1               category3         (null)       <br /> 2               subcategory5      1            <br /> 3               subcategory4      1            <br /> 4               subsubcategory4   3            <br /> 5               category2         (null)       <br /> 6               subcategory3      5            <br /><br /> 6 record(s) selected<br /><br /></pre><br /><br />Woah!  Whats going on here?  We havent told Oracle how to sort the results, so Oracle is picking the method it thinks is best.  A good rule of when working with data sets is to allways specify an ORDER BY clause to guarntee you get the results back in the way you expect.<br /><br />So, how can we fix the order of this recordset?  We cant.  We need more data to allow us to tell Oracle how to sort these records.  We need a sort order column.  So lets revisit our table creation statment with our new colum "sort_order" with values for sorting:<br /><br /><pre><br /><br />DROP TABLE categories;<br /><br />CREATE TABLE categories (<br />category_id INT NOT NULL PRIMARY KEY,<br />category_name VARCHAR2(128) NOT NULL,<br />parent_id INT NULL,<br />sort_order INT NOT NULL<br />);<br /><br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(1,'category1',NULL,1);<br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(2,'subcategory1',1,1);<br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(3,'subcategory2',1,2);<br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(4,'subsubcategory1',3,1);<br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(5,'category2',NULL,2);<br />INSERT INTO categories (category_id, category_name,parent_id,sort_order)<br />VALUES(6,'subcategory3',5,1);<br />COMMIT;<br /></pre><br /><br />I've added a sort order column and I have chosen to order each record within the higharchy level that I know it should be returned within.<br />This means that sort_orders will only be unique within a tier for a given parent.  If I lost you with that last statement, just keep reading, we will address that issue soon.<br />Here is how our data looks now:<br /><br /><pre><br />SELECT * FROM categories;<br /><br /> CATEGORY_ID     CATEGORY_NAME     PARENT_ID     SORT_ORDER    <br /> --------------  ----------------  ------------  ------------- <br /> 1               category3         (null)        2             <br /> 2               subcategory5      1             2             <br /> 3               subcategory4      1             1             <br /> 4               subsubcategory4   3             1             <br /> 5               category2         (null)        1             <br /> 6               subcategory3      5             1             <br /><br /> 6 record(s) selected  <br /></pre><br /><br />Here we see the basic sorting problem.  We now have all the information that we should need to create and sort our higharchy.  <br />So where do we go from here?  Lets see what happens when we sort on the sort_order column:<br /><br /><pre><br />SELECT * FROM categories ORDER BY sort_order;<br /><br /> CATEGORY_ID     CATEGORY_NAME     PARENT_ID     SORT_ORDER    <br /> --------------  ----------------  ------------  ------------- <br /> 3               subcategory4      1             1             <br /> 4               subsubcategory4   3             1             <br /> 5               category2         (null)        1             <br /> 6               subcategory3      5             1             <br /> 1               category3         (null)        2             <br /> 2               subcategory5      1             2             <br /><br /> 6 record(s) selected<br /><br /></pre><br /><br />We are not taking into account the higharchy level, so the sorting does not work.  (as a side note, we could do absolute sorting where the sort order column is unique, but lets continue to explore this solution first)<br /><br />What we really need to do is somehow get the results returned already ordered by the higharchy level, then sub-sort by the sort order.  SQL does not support returning trees in this way (that I know of) so after searching google I found a suggestion from oracle on how to do this in oracle 9i (the Database I'm currently using)...if you are using 10g, it should be even easier.  Check out the article for more info:<br /><br />http://www.oracle.com/technology/oramag/oracle/05-may/o35asktom.html<br /><br />Anywho, their version of the solution is a bit hard to understand, so here is my simpler version that solves our problem:<br /><br /><pre><br />SELECT  category_name,<br />  category_id,<br />  level, <br />  sort_order<br />FROM    categories<br />START WITH parent_id IS NULL<br />CONNECT BY PRIOR category_id = parent_id<br />ORDER SIBLINGS BY sort_order;<br /><br /></pre><br /><br />This is an oracle specific solution.  The SYS_CONNECT_BY_PATH function, START WITH and CONNECT BY PRIOR statements are all non-standard oracle features.  I have no idea how you would do this in pure SQL...I assume you would need to write some procedual code to do the work for you.<br /><br />Lets break down how this works:
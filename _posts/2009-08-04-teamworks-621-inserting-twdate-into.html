---
title: Teamworks 6.2.1 - Inserting TWDate into Oracle 10g Timestamp Column
date: '2009-08-04T15:44:00.001-07:00'
tags:
- Teamworks
- Lombardi
modified_time: '2010-01-13T09:17:40.213-08:00'
thumbnail: http://2.bp.blogspot.com/_It8-g3_9vec/SnjZruh5mMI/AAAAAAAAAuM/sRTTpJ3iVl4/s72-c/SQLCallStatementService.JPG
blogger_id: tag:blogger.com,1999:blog-19111454.post-8639810072672534754
blogger_orig_url: http://www.bryansgeekspeak.com/2009/08/teamworks-621-inserting-twdate-into.html
---

I've recently moved away from the "SQL Execute Statement" services in teamworks in favor of the "SQL Call Statement" versions that use the SQLStatement datatype for input and SQLResult type for output.  This way, all SQL calls are formatted using the same SQLStatement type and all results returned in the same standard catch all SQLResults complex type.  Even better, using the SQLStatement type encourages the use of SQL parameters ... which helps with query plan caching in oracle, avoids a lot of string parsing issues with appending variables directly to the SQL execute string, and also helps prevent <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection</a>.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_It8-g3_9vec/SnjZruh5mMI/AAAAAAAAAuM/sRTTpJ3iVl4/s1600-h/SQLCallStatementService.JPG"><img style="cursor:pointer; cursor:hand;width: 320px; height: 194px;" src="http://2.bp.blogspot.com/_It8-g3_9vec/SnjZruh5mMI/AAAAAAAAAuM/sRTTpJ3iVl4/s320/SQLCallStatementService.JPG" border="0" alt="Location of SQL Services in Teamworks Authoring Environment" title="Location of SQL Services within Teamworks Authoring Environment"id="BLOGGER_PHOTO_ID_5366278301259765954" /></a><br /><br />Anyhow, I ran into an issue with passing TWDate values into the teamworks "SQL Call Statement" service as a type TIMESTAMP SQL parameter.  I still dont know if this is an oracle issue or a JDBC issue...or if it is some other timezone/locale thing.  Whatever the case, I ended up string formatting the TWDate value into something suitable for JDBC to plug into Oracle as a TIMESTAMP column type. Below is an example teamworks server script that shows how it all works, assuming the oracle table has two columns: ID of type INT and CreateDate of type TIMESTAMP.<br /><br /><div class="code">tw.local.dsn = "jdbc/mydsn";<br />tw.local.thisDate = new TWDate();<br />tw.local.sqlStatement = new tw.object.SQLStatement();<br />tw.local.sqlStatement.sql = "INSERT INTO TestTimestampeTable (ID,CreateDate)VALUES(?,?)";<br />tw.local.sqlStatement.parameters = new tw.object.arrayOf.SQLParameter();<br />tw.local.sqlStatement.parameters[0] = new tw.object.SQLParameter();<br />tw.local.sqlStatement.parameters[0].value = 1;<br />tw.local.sqlStatement.parameters[0].type = "INTEGER";<br />tw.local.sqlStatement.parameters[1] = new tw.object.SQLParameter();<br />tw.local.sqlStatement.parameters[1].value = tw.local.thisDate.format('<span style="background-color: yellow">yyyy-MM-dd H:mm:ss.SSS</span>');<br />tw.local.sqlStatement.parameters[1].type = "TIMESTAMP";<br />tw.local.sqlStatement.maxRows = 0;<br /></div><br />Once you have the sqlStatement set, all you have to do is map variables to the service, similar to that shown below.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://4.bp.blogspot.com/_It8-g3_9vec/Snjd0wOCqwI/AAAAAAAAAuU/Jt-Ex0ephKk/s1600-h/SQLCallVarMapping.JPG"><img style="cursor:pointer; cursor:hand;width: 320px; height: 113px;" src="http://4.bp.blogspot.com/_It8-g3_9vec/Snjd0wOCqwI/AAAAAAAAAuU/Jt-Ex0ephKk/s320/SQLCallVarMapping.JPG" border="0" alt="Mapping SQLStatement vars to the SQL Call Statement Service in Teamworks" title="Mapping SQLStatement vars to the SQL Call Statement Service in Teamworks" id="BLOGGER_PHOTO_ID_5366282854378679042" /></a><br /><br /><br />- ... and just a few minutes later... -<br /><br />OR! you can apparently just shove the TWDate object right into the SQL parameter value and it just magically converts to the right format for you. (it also helps to be using the right oracle query when verifying data was inserted properly into oracle x.x; ). Here's the simpler method ... just change the server script to this:<br /><br /><div class="code">tw.local.dsn = "jdbc/mydsn";<br />tw.local.thisDate = new TWDate();<br />tw.local.sqlStatement = new tw.object.SQLStatement();<br />tw.local.sqlStatement.sql = "INSERT INTO TestTimestampeTable (ID,CreateDate)VALUES(?,?)";<br />tw.local.sqlStatement.parameters = new tw.object.arrayOf.SQLParameter();<br />tw.local.sqlStatement.parameters[0] = new tw.object.SQLParameter();<br />tw.local.sqlStatement.parameters[0].value = 1;<br />tw.local.sqlStatement.parameters[0].type = "INTEGER";<br />tw.local.sqlStatement.parameters[1] = new tw.object.SQLParameter();<br />tw.local.sqlStatement.parameters[1].value = <span style="background-color: yellow">tw.local.thisDate</span>;<br />tw.local.sqlStatement.parameters[1].type = "TIMESTAMP";<br />tw.local.sqlStatement.maxRows = 0;<br /></div><br />To validate from oracle, you'll want to run a query like this from SQL plus:<br /><br /><div class="code">SELECT ID,TO_CHAR(createDate,'mm/dd/yyyy HH:MI:SS.FF PM') FROM TestTimestampeTable;<br /></div>